// Package main - Uygulaman\u0131n giri\u015f noktas\u0131 (entry point)
// cmd/api/ = Executable binary'nin bulundu\u011fu yer
// Go'da her executable bir main package ve main() fonksiyonu i\u00e7ermelidir
package main

import (
	"context"     // Context management (timeout, cancel)
	"log"         // Logging (basit, production'da zerolog/zap kullan\u0131l\u0131r)
	"net/http"    // HTTP server
	"os"          // OS i\u015flemleri (signals, environment variables)
	"os/signal"   // OS signal'lerini yakalamak i\u00e7in (SIGINT, SIGTERM)
	"syscall"     // System calls
	"time"        // Zaman i\u015flemleri

	// Internal packages (bizim projemizin paketleri)
	// Go module ad\u0131 + relative path
	"auth-service/config"                                // Configuration management
	"auth-service/internal/application/usecase"          // Business logic (Use Cases)
	"auth-service/internal/infrastructure/repository"    // Database repositories
	"auth-service/internal/presentation/http/handler"    // HTTP handlers (controllers)
	"auth-service/internal/presentation/http/middleware" // HTTP middleware
	"auth-service/pkg/database"                          // Database connection
	"auth-service/pkg/security"                          // Security services (JWT, password)

	// External packages (3rd party k\u00fct\u00fcphaneler)
	"github.com/gin-contrib/cors" // CORS middleware for Gin
	"github.com/gin-gonic/gin"    // Gin web framework
)

// Swagger annotations - API dok√ºmantasyonu i\u00e7in
// swag init komutu ile otomatik docs olu\u015fturulur
// @title Auth Service API
// @version 1.0
// @description Enterprise Auth Microservice with Clean Architecture
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.email support@authservice.com

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host localhost:5004
// @BasePath /api

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// main - Uygulaman\u0131n ba\u015flang\u0131\u00e7 fonksiyonu
// Go program\u0131 main() fonksiyonundan \u00e7al\u0131\u015fmaya ba\u015flar
// Dependency Injection (DI) pattern'\u0131 kullan\u0131l\u0131r:\n// 1. Config y\u00fckle\n// 2. Database ba\u011flan\n// 3. Repository'leri olu\u015ftur\n// 4. Service'leri olu\u015ftur\n// 5. Use Case'leri olu\u015ftur\n// 6. Handler'lar\u0131 olu\u015ftur\n// 7. Router'i kur\n// 8. Server'i ba\u015flat\nfunc main() {
	// ===== 1. CONFIGURATION =====\n\t// .env dosyas\u0131n\u0131 y\u00fckle ve config struct'\u0131na parse et\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\t// Fatalf = Error log'la ve program\u0131 sonland\u0131r (exit code 1)\n\t\t// %v = value formatter (any type'i string'e \u00e7evirir)\n\t\tlog.Fatalf(\"\u274c Failed to load configuration: %v\", err)\n\t}\n\n\t// ===== 2. GIN MODE =====\n\t// Gin'in \u00e7al\u0131\u015fma modu: \"debug\", \"release\" veya \"test\"\n\t// debug = verbose logging, release = production mode (daha h\u0131zl\u0131)\n\tgin.SetMode(cfg.Server.Mode)\n\n\t// ===== 3. DATABASE CONNECTION =====\n\t// PostgreSQL'e ba\u011flan ve GORM instance'\u0131 al\n\t// & = cfg.Database struct'\u0131n\u0131n pointer'\u0131n\u0131 g\u00f6nder (memory efficient)\n\tdb, err := database.NewPostgresDB(&cfg.Database)\n\tif err != nil {\n\t\tlog.Fatalf(\"\u274c Failed to connect to database: %v\", err)\n\t}\n\n\t// ===== 4. REPOSITORIES (Data Access Layer) =====\n\t// Repository Pattern: Database access'\u0131 kaps\u00fclleyen layer\n\t// Bu sayede database de\u011fi\u015firse sadece repository'leri de\u011fi\u015ftiririz\n\tuserRepo := repository.NewUserRepository(db)\n\trefreshTokenRepo := repository.NewRefreshTokenRepository(db)\n\n\t// ===== 5. SERVICES (Security Layer) =====\n\t// JWT token olu\u015fturma/do\u011frulama servisi\n\tjwtService := security.NewJWTService(\n\t\tcfg.JWT.Secret,                // Secret key (.env'den gelir)\n\t\tcfg.JWT.AccessTokenExpiry,     // 15 dakika\n\t\tcfg.JWT.RefreshTokenExpiry,    // 7 g\u00fcn\n\t)\n\t// \u015eifre hash'leme/kar\u015f\u0131la\u015ft\u0131rma servisi (bcrypt)\n\tpasswordService := security.NewPasswordService(cfg.Security.BcryptCost)\n\n\t// ===== 6. USE CASES (Business Logic Layer) =====\n\t// Clean Architecture'da i\u015f mant\u0131\u011f\u0131 use case'lerde bulunur\n\t// T\u00fcm dependencies inject edilir (DI pattern)\n\tauthUseCase := usecase.NewAuthUseCase(\n\t\tuserRepo,                       // User repository\n\t\trefreshTokenRepo,               // Token repository\n\t\tjwtService,                     // JWT service\n\t\tpasswordService,                // Password service\n\t\tcfg.JWT.AccessTokenExpiry,      // Token expiry config\n\t\tcfg.JWT.RefreshTokenExpiry,\n\t)\n\n\t// ===== 7. HANDLERS (Presentation Layer) =====\n\t// HTTP request'leri handle eden controller'lar\n\t// Use case'leri \u00e7a\u011f\u0131r\u0131r ve response d\u00f6ner\n\tauthHandler := handler.NewAuthHandler(authUseCase, jwtService)\n\n\t// ===== 8. ROUTER SETUP =====\n\t// Gin router'\u0131 kur: routes, middleware, CORS\n\trouter := setupRouter(cfg, authHandler, jwtService)\n\n\t// ===== 9. HTTP SERVER =====\n\t// Go'nun standard library HTTP server'\u0131\n\tsrv := &http.Server{\n\t\t// Address - Server'in dinleyece\u011fi adres ve port\n\t\t// 0.0.0.0:5004 = T\u00fcm network interface'lerinde 5004 portunu dinle\n\t\tAddr:           cfg.Server.Host + \":\" + cfg.Server.Port,\n\t\t\n\t\t// Handler - Gin router (http.Handler interface'ini implement eder)\n\t\tHandler:        router,\n\t\t\n\t\t// ReadTimeout - Request body'i okumak i\u00e7in max s\u00fcre\n\t\t// Slowloris attack gibi sald\u0131r\u0131lara kar\u015f\u0131 koruma\n\t\tReadTimeout:    10 * time.Second,\n\t\t\n\t\t// WriteTimeout - Response yazmak i\u00e7in max s\u00fcre\n\t\tWriteTimeout:   10 * time.Second,\n\t\t\n\t\t// MaxHeaderBytes - Request header'lar\u0131n max boyutu\n\t\t// 1 << 20 = 1 MB (bit shift: 1 * 2^20)\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\t// ===== 10. GRACEFUL SHUTDOWN =====\n\t// Goroutine - Go'nun lightweight thread'i\n\t// go keyword = fonksiyonu ayr\u0131 bir goroutine'de \u00e7al\u0131\u015ft\u0131r (async)\n\tgo func() {\n\t\t// Printf = formatted print (\u00e7\u0131kt\u0131 vermek i\u00e7in)\n\t\tlog.Printf(\"\ud83d\ude80 Auth Service starting on %s:%s\", cfg.Server.Host, cfg.Server.Port)\n\t\t\n\t\t// Server'i ba\u015flat (blocking call - server kapanana kadar bekler)\n\t\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\t// ErrServerClosed = Normal shutdown, di\u011ferleri hata\n\t\t\tlog.Fatalf(\"\u274c Failed to start server: %v\", err)\n\t\t}\n\t}()  // () = goroutine'i hemen \u00e7al\u0131\u015ft\u0131r\n\n\t// ===== 11. SIGNAL HANDLING =====\n\t// OS signal'lerini yakalamak i\u00e7in channel olu\u015ftur\n\t// Channel = Go'nun goroutine'ler aras\u0131 ileti\u015fim arac\u0131\n\t// make() = channel olu\u015fturma, buffer size = 1\n\tquit := make(chan os.Signal, 1)\n\t\n\t// SIGINT (Ctrl+C) ve SIGTERM signal'lerini yakala\n\t// signal.Notify = Bu signal'ler geldi\u011finde quit channel'\u0131na g\u00f6nder\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\n\t// Channel'dan signal bekle (blocking)\n\t// <-quit = Channel'dan okuma, signal gelene kadar bekler\n\t<-quit\n\n\tlog.Println(\"\ud83d\uded1 Shutting down server...\")\n\n\t// ===== 12. GRACEFUL SHUTDOWN =====\n\t// Context with timeout - 5 saniye i\u00e7inde kapat\n\t// WithTimeout = Belirli s\u00fcre sonra otomatik cancel olan context\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t// defer = Fonksiyon bitince \u00e7al\u0131\u015f\u0131r (cleanup i\u00e7in kullan\u0131l\u0131r)\n\tdefer cancel()  // Context'i serbest b\u0131rak (memory leak'i \u00f6nler)\n\n\t// Server'i graceful kapat\n\t// Graceful shutdown = Mevcut request'leri tamamla, yenilerini alma\n\tif err := srv.Shutdown(ctx); err != nil {\n\t\tlog.Fatalf(\"\u274c Server forced to shutdown: %v\", err)\n\t}\n\n\tlog.Println(\"\u2705 Server exited successfully\")\n}

// setupRouter - Gin router'\u0131 yap\u0131land\u0131r\u0131r\n// Bu fonksiyon:\n// 1. Middleware'leri ekler (logger, recovery, CORS)\n// 2. Route'lar\u0131 tan\u0131mlar (public ve protected)\n// 3. Handler'lar\u0131 route'lara ba\u011flar\nfunc setupRouter(cfg *config.Config, authHandler *handler.AuthHandler, jwtService *security.JWTService) *gin.Engine {\n\t// Yeni Gin router olu\u015ftur (default middleware'ler YOK)\n\t// gin.New() vs gin.Default():\n\t// - New() = Bo\u015f router (middleware kendimiz ekleriz)\n\t// - Default() = Logger + Recovery middleware'li\n\trouter := gin.New()\n\n\t// ===== MIDDLEWARE =====\n\t// Middleware = Her request'te \u00e7al\u0131\u015fan fonksiyonlar (chain of responsibility pattern)\n\t// S\u0131ralama \u00f6nemli! Yukar\u0131dan a\u015fa\u011f\u0131ya \u00e7al\u0131\u015f\u0131r.\n\t\n\t// 1. Logger - Request'leri loglar (method, path, status, latency)\n\trouter.Use(gin.Logger())\n\t\n\t// 2. Recovery - Panic olursa yakalar ve 500 d\u00f6ner (crash \u00f6nler)\n\t// Go'da panic = exception gibi, ama kullan\u0131m\u0131 nadir\n\trouter.Use(gin.Recovery())\n\n\t// 3. CORS - Cross-Origin Resource Sharing\n\t// Frontend (React, Vue vs.) farkl\u0131 domain'den API'yi \u00e7a\u011f\u0131rabilsin\n\t// \u00d6rnek: Frontend http://localhost:3000, Backend http://localhost:5004\n\trouter.Use(cors.New(cors.Config{\n\t\t// AllowOrigins - Hangi origin'lerden request kabul edilir\n\t\t// .env'den gelir: \"http://localhost:3000,http://localhost:5000\"\n\t\tAllowOrigins:     cfg.CORS.AllowedOrigins,\n\t\t\n\t\t// AllowMethods - Hangi HTTP methodlar\u0131 izinli (GET, POST, PUT, DELETE vs.)\n\t\tAllowMethods:     cfg.CORS.AllowedMethods,\n\t\t\n\t\t// AllowHeaders - Hangi header'lar g\u00f6nderilebilir (Authorization, Content-Type vs.)\n\t\tAllowHeaders:     cfg.CORS.AllowedHeaders,\n\t\t\n\t\t// AllowCredentials - Cookie ve Authorization header g\u00f6nderilebilir mi\n\t\tAllowCredentials: true,\n\t\t\n\t\t// MaxAge - Preflight request cache s\u00fcresi (OPTIONS request'i tekrarlanmaz)\n\t\tMaxAge:           12 * time.Hour,\n\t}))\n\n\t// ===== HEALTH CHECK =====\n\t// Kubernetes, Docker, load balancer'lar i\u00e7in\n\t// GET /health -> 200 OK = servis sa\u011fl\u0131kl\u0131\n\trouter.GET(\"/health\", authHandler.Health)\n\n\t// ===== API ROUTES =====\n\t// Route grouping - \"/api\" prefix'li t\u00fcm route'lar\n\t// Group = Route'lar\u0131 organize etmek i\u00e7in (namespace gibi)\n\tapi := router.Group(\"/api\")\n\t{\n\t\t// Auth route group - \"/api/auth\" prefix'li route'lar\n\t\tauth := api.Group(\"/auth\")\n\t\t{\n\t\t\t// ===== PUBLIC ROUTES (Authentication gerekmez) =====\n\t\t\t// POST /api/auth/register - Yeni kullan\u0131c\u0131 kayd\u0131\n\t\t\tauth.POST(\"/register\", authHandler.Register)\n\t\t\t\n\t\t\t// POST /api/auth/login - Kullan\u0131c\u0131 giri\u015fi\n\t\t\tauth.POST(\"/login\", authHandler.Login)\n\t\t\t\n\t\t\t// POST /api/auth/refresh - Token yenileme\n\t\t\tauth.POST(\"/refresh\", authHandler.RefreshToken)\n\n\t\t\t// ===== PROTECTED ROUTES (JWT token gerekir) =====\n\t\t\t// Sub-group olu\u015ftur ve middleware ekle\n\t\t\tprotected := auth.Group(\"\")\n\t\t\t// AuthMiddleware - JWT token'\u0131 do\u011frular\n\t\t\t// Token ge\u00e7ersizse 401 Unauthorized d\u00f6ner\n\t\t\tprotected.Use(middleware.AuthMiddleware(jwtService))\n\t\t\t{\n\t\t\t\t// POST /api/auth/logout - Kullan\u0131c\u0131 \u00e7\u0131k\u0131\u015f\u0131\n\t\t\t\t// Token'dan user ID \u00e7\u0131kar\u0131l\u0131r (middleware set eder)\n\t\t\t\tprotected.POST(\"/logout\", authHandler.Logout)\n\t\t\t\t\n\t\t\t\t// GET /api/auth/me - Mevcut kullan\u0131c\u0131 bilgisi\n\t\t\t\t// Frontend'de \"Profil\" sayfas\u0131 i\u00e7in\n\t\t\t\tprotected.GET(\"/me\", authHandler.Me)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Router'\u0131 d\u00f6nd\u00fcr\n\treturn router\n}
